/* tslint:disable */
/* eslint-disable */
// Generated by Microsoft Kiota
// @ts-ignore
import { type AdditionalDataHolder, type ApiError, type Parsable, type ParseNode, type SerializationWriter } from '@microsoft/kiota-abstractions';

/**
 * The total amount that should be received by the receiver when this outgoing payment has been paid.
 */
export interface Amount extends AdditionalDataHolder, Parsable {
    /**
     * The assetCode is a code that indicates the underlying asset. An ISO4217 currency code should be used whenever possible. The ISO4217 representation of the US Dollar is USD.
     */
    assetCode?: string | null;
    /**
     * The number of decimal places that defines the scale of the smallest divisible unit for the given asset code. It determines how an integer amount is scaled to derive the actual monetary value. For example, USD has an asset scale of 2 with the smallest unit being 0.01. An integer amount of `1000` with an `assetCode` of `USD` and `assetScale` of `2` translates to $10.00.
     */
    assetScale?: number | null;
    /**
     * The value is an unsigned 64-bit integer amount, represented as a string.
     */
    value?: string | null;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Amount}
 */
// @ts-ignore
export function createAmountFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoAmount;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ErrorResponse_error_details}
 */
// @ts-ignore
export function createErrorResponse_error_detailsFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoErrorResponse_error_details;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ErrorResponse_error}
 */
// @ts-ignore
export function createErrorResponse_errorFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoErrorResponse_error;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {ErrorResponse}
 */
// @ts-ignore
export function createErrorResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoErrorResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {IlpPaymentMethod}
 */
// @ts-ignore
export function createIlpPaymentMethodFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoIlpPaymentMethod;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {IncomingPayment_metadata}
 */
// @ts-ignore
export function createIncomingPayment_metadataFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoIncomingPayment_metadata;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {IncomingPayment}
 */
// @ts-ignore
export function createIncomingPaymentFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoIncomingPayment;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {IncomingPaymentWithMethods}
 */
// @ts-ignore
export function createIncomingPaymentWithMethodsFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoIncomingPaymentWithMethods;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {OutgoingPayment_metadata}
 */
// @ts-ignore
export function createOutgoingPayment_metadataFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoOutgoingPayment_metadata;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {OutgoingPayment}
 */
// @ts-ignore
export function createOutgoingPaymentFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoOutgoingPayment;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {OutgoingPaymentWithSpentAmounts_metadata}
 */
// @ts-ignore
export function createOutgoingPaymentWithSpentAmounts_metadataFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoOutgoingPaymentWithSpentAmounts_metadata;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {OutgoingPaymentWithSpentAmounts}
 */
// @ts-ignore
export function createOutgoingPaymentWithSpentAmountsFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoOutgoingPaymentWithSpentAmounts;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {PageInfo}
 */
// @ts-ignore
export function createPageInfoFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoPageInfo;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {PublicIncomingPayment}
 */
// @ts-ignore
export function createPublicIncomingPaymentFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoPublicIncomingPayment;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {Quote}
 */
// @ts-ignore
export function createQuoteFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoQuote;
}
/**
 * The deserialization information for the current model
 * @param Amount The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoAmount(amount: Partial<Amount> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "assetCode": n => { amount.assetCode = n.getStringValue(); },
        "assetScale": n => { amount.assetScale = n.getNumberValue(); },
        "value": n => { amount.value = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param ErrorResponse The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoErrorResponse(errorResponse: Partial<ErrorResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "error": n => { errorResponse.errorEscaped = n.getObjectValue<ErrorResponse_error>(createErrorResponse_errorFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param ErrorResponse_error The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoErrorResponse_error(errorResponse_error: Partial<ErrorResponse_error> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "code": n => { errorResponse_error.code = n.getStringValue(); },
        "description": n => { errorResponse_error.description = n.getStringValue(); },
        "details": n => { errorResponse_error.details = n.getObjectValue<ErrorResponse_error_details>(createErrorResponse_error_detailsFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param ErrorResponse_error_details The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoErrorResponse_error_details(errorResponse_error_details: Partial<ErrorResponse_error_details> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
    }
}
/**
 * The deserialization information for the current model
 * @param IlpPaymentMethod The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoIlpPaymentMethod(ilpPaymentMethod: Partial<IlpPaymentMethod> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "ilpAddress": n => { ilpPaymentMethod.ilpAddress = n.getStringValue(); },
        "sharedSecret": n => { ilpPaymentMethod.sharedSecret = n.getStringValue(); },
        "type": n => { ilpPaymentMethod.type = n.getEnumValue<IlpPaymentMethod_type>(IlpPaymentMethod_typeObject); },
    }
}
/**
 * The deserialization information for the current model
 * @param IncomingPayment The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoIncomingPayment(incomingPayment: Partial<IncomingPayment> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "completed": n => { incomingPayment.completed = n.getBooleanValue(); },
        "createdAt": n => { incomingPayment.createdAt = n.getDateValue(); },
        "expiresAt": n => { incomingPayment.expiresAt = n.getDateValue(); },
        "id": n => { incomingPayment.id = n.getStringValue(); },
        "incomingAmount": n => { incomingPayment.incomingAmount = n.getObjectValue<Amount>(createAmountFromDiscriminatorValue); },
        "metadata": n => { incomingPayment.metadata = n.getObjectValue<IncomingPayment_metadata>(createIncomingPayment_metadataFromDiscriminatorValue); },
        "receivedAmount": n => { incomingPayment.receivedAmount = n.getObjectValue<Amount>(createAmountFromDiscriminatorValue); },
        "walletAddress": n => { incomingPayment.walletAddress = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param IncomingPayment_metadata The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoIncomingPayment_metadata(incomingPayment_metadata: Partial<IncomingPayment_metadata> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
    }
}
/**
 * The deserialization information for the current model
 * @param IncomingPaymentWithMethods The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoIncomingPaymentWithMethods(incomingPaymentWithMethods: Partial<IncomingPaymentWithMethods> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        ...deserializeIntoIncomingPayment(incomingPaymentWithMethods),
        "methods": n => { incomingPaymentWithMethods.methods = n.getCollectionOfObjectValues<IlpPaymentMethod>(createIlpPaymentMethodFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param OutgoingPayment The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoOutgoingPayment(outgoingPayment: Partial<OutgoingPayment> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "createdAt": n => { outgoingPayment.createdAt = n.getDateValue(); },
        "debitAmount": n => { outgoingPayment.debitAmount = n.getObjectValue<Amount>(createAmountFromDiscriminatorValue); },
        "failed": n => { outgoingPayment.failed = n.getBooleanValue(); },
        "id": n => { outgoingPayment.id = n.getStringValue(); },
        "metadata": n => { outgoingPayment.metadata = n.getObjectValue<OutgoingPayment_metadata>(createOutgoingPayment_metadataFromDiscriminatorValue); },
        "quoteId": n => { outgoingPayment.quoteId = n.getStringValue(); },
        "receiveAmount": n => { outgoingPayment.receiveAmount = n.getObjectValue<Amount>(createAmountFromDiscriminatorValue); },
        "receiver": n => { outgoingPayment.receiver = n.getStringValue(); },
        "sentAmount": n => { outgoingPayment.sentAmount = n.getObjectValue<Amount>(createAmountFromDiscriminatorValue); },
        "walletAddress": n => { outgoingPayment.walletAddress = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param OutgoingPayment_metadata The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoOutgoingPayment_metadata(outgoingPayment_metadata: Partial<OutgoingPayment_metadata> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
    }
}
/**
 * The deserialization information for the current model
 * @param OutgoingPaymentWithSpentAmounts The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoOutgoingPaymentWithSpentAmounts(outgoingPaymentWithSpentAmounts: Partial<OutgoingPaymentWithSpentAmounts> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "createdAt": n => { outgoingPaymentWithSpentAmounts.createdAt = n.getDateValue(); },
        "debitAmount": n => { outgoingPaymentWithSpentAmounts.debitAmount = n.getObjectValue<Amount>(createAmountFromDiscriminatorValue); },
        "failed": n => { outgoingPaymentWithSpentAmounts.failed = n.getBooleanValue(); },
        "grantSpentDebitAmount": n => { outgoingPaymentWithSpentAmounts.grantSpentDebitAmount = n.getObjectValue<Amount>(createAmountFromDiscriminatorValue); },
        "grantSpentReceiveAmount": n => { outgoingPaymentWithSpentAmounts.grantSpentReceiveAmount = n.getObjectValue<Amount>(createAmountFromDiscriminatorValue); },
        "id": n => { outgoingPaymentWithSpentAmounts.id = n.getStringValue(); },
        "metadata": n => { outgoingPaymentWithSpentAmounts.metadata = n.getObjectValue<OutgoingPaymentWithSpentAmounts_metadata>(createOutgoingPaymentWithSpentAmounts_metadataFromDiscriminatorValue); },
        "quoteId": n => { outgoingPaymentWithSpentAmounts.quoteId = n.getStringValue(); },
        "receiveAmount": n => { outgoingPaymentWithSpentAmounts.receiveAmount = n.getObjectValue<Amount>(createAmountFromDiscriminatorValue); },
        "receiver": n => { outgoingPaymentWithSpentAmounts.receiver = n.getStringValue(); },
        "sentAmount": n => { outgoingPaymentWithSpentAmounts.sentAmount = n.getObjectValue<Amount>(createAmountFromDiscriminatorValue); },
        "walletAddress": n => { outgoingPaymentWithSpentAmounts.walletAddress = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param OutgoingPaymentWithSpentAmounts_metadata The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoOutgoingPaymentWithSpentAmounts_metadata(outgoingPaymentWithSpentAmounts_metadata: Partial<OutgoingPaymentWithSpentAmounts_metadata> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
    }
}
/**
 * The deserialization information for the current model
 * @param PageInfo The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoPageInfo(pageInfo: Partial<PageInfo> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "endCursor": n => { pageInfo.endCursor = n.getStringValue(); },
        "hasNextPage": n => { pageInfo.hasNextPage = n.getBooleanValue(); },
        "hasPreviousPage": n => { pageInfo.hasPreviousPage = n.getBooleanValue(); },
        "startCursor": n => { pageInfo.startCursor = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param PublicIncomingPayment The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoPublicIncomingPayment(publicIncomingPayment: Partial<PublicIncomingPayment> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "authServer": n => { publicIncomingPayment.authServer = n.getStringValue(); },
        "receivedAmount": n => { publicIncomingPayment.receivedAmount = n.getObjectValue<Amount>(createAmountFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param Quote The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoQuote(quote: Partial<Quote> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "createdAt": n => { quote.createdAt = n.getDateValue(); },
        "debitAmount": n => { quote.debitAmount = n.getObjectValue<Amount>(createAmountFromDiscriminatorValue); },
        "expiresAt": n => { quote.expiresAt = n.getStringValue(); },
        "id": n => { quote.id = n.getStringValue(); },
        "method": n => { quote.method = n.getEnumValue<PaymentMethod>(PaymentMethodObject); },
        "receiveAmount": n => { quote.receiveAmount = n.getObjectValue<Amount>(createAmountFromDiscriminatorValue); },
        "receiver": n => { quote.receiver = n.getStringValue(); },
        "walletAddress": n => { quote.walletAddress = n.getStringValue(); },
    }
}
export interface ErrorResponse extends AdditionalDataHolder, ApiError, Parsable {
    /**
     * The error property
     */
    errorEscaped?: ErrorResponse_error | null;
}
export interface ErrorResponse_error extends AdditionalDataHolder, Parsable {
    /**
     * The code property
     */
    code?: string | null;
    /**
     * The description property
     */
    description?: string | null;
    /**
     * Additional details about the error.
     */
    details?: ErrorResponse_error_details | null;
}
/**
 * Additional details about the error.
 */
export interface ErrorResponse_error_details extends AdditionalDataHolder, Parsable {
}
export interface IlpPaymentMethod extends Parsable {
    /**
     * The ILP address to use when establishing a STREAM connection.
     */
    ilpAddress?: string | null;
    /**
     * The base64 url-encoded shared secret to use when establishing a STREAM connection.
     */
    sharedSecret?: string | null;
    /**
     * The type property
     */
    type?: IlpPaymentMethod_type | null;
}
export type IlpPaymentMethod_type = (typeof IlpPaymentMethod_typeObject)[keyof typeof IlpPaymentMethod_typeObject];
/**
 * An **incoming payment** resource represents a payment that will be, is currently being, or has been received by the account.
 */
export interface IncomingPayment extends AdditionalDataHolder, Parsable {
    /**
     * Describes whether the incoming payment has completed receiving fund.
     */
    completed?: boolean | null;
    /**
     * The date and time when the incoming payment was created.
     */
    createdAt?: Date | null;
    /**
     * The date and time when payments under this incoming payment will no longer be accepted.
     */
    expiresAt?: Date | null;
    /**
     * The URL identifying the incoming payment.
     */
    id?: string | null;
    /**
     * The maximum amount that should be paid into the wallet address under this incoming payment.
     */
    incomingAmount?: Amount | null;
    /**
     * Additional metadata associated with the incoming payment. (Optional)
     */
    metadata?: IncomingPayment_metadata | null;
    /**
     * The total amount that has been paid into the wallet address under this incoming payment.
     */
    receivedAmount?: Amount | null;
    /**
     * The URL of the wallet address this payment is being made into.
     */
    walletAddress?: string | null;
}
/**
 * Additional metadata associated with the incoming payment. (Optional)
 */
export interface IncomingPayment_metadata extends AdditionalDataHolder, Parsable {
}
/**
 * An **incoming payment** resource with public details.
 */
export interface IncomingPaymentWithMethods extends IncomingPayment, Parsable {
    /**
     * The list of payment methods supported by this incoming payment.
     */
    methods?: IlpPaymentMethod[] | null;
}
/**
 * An **outgoing payment** resource represents a payment that will be, is currently being, or has previously been, sent from the wallet address.
 */
export interface OutgoingPayment extends Parsable {
    /**
     * The date and time when the outgoing payment was created.
     */
    createdAt?: Date | null;
    /**
     * The total amount that should be deducted from the sender's account when this outgoing payment has been paid.
     */
    debitAmount?: Amount | null;
    /**
     * Describes whether the payment failed to send its full amount.
     */
    failed?: boolean | null;
    /**
     * The URL identifying the outgoing payment.
     */
    id?: string | null;
    /**
     * Additional metadata associated with the outgoing payment. (Optional)
     */
    metadata?: OutgoingPayment_metadata | null;
    /**
     * The URL of the quote defining this payment's amounts.
     */
    quoteId?: string | null;
    /**
     * The total amount that should be received by the receiver when this outgoing payment has been paid.
     */
    receiveAmount?: Amount | null;
    /**
     * The URL of the incoming payment that is being paid.
     */
    receiver?: string | null;
    /**
     * The total amount that has been sent under this outgoing payment.
     */
    sentAmount?: Amount | null;
    /**
     * The URL of the wallet address from which this payment is sent.
     */
    walletAddress?: string | null;
}
/**
 * Additional metadata associated with the outgoing payment. (Optional)
 */
export interface OutgoingPayment_metadata extends AdditionalDataHolder, Parsable {
}
/**
 * An **outgoing payment** resource represents a payment that will be, is currently being, or has previously been, sent from the wallet address.
 */
export interface OutgoingPaymentWithSpentAmounts extends AdditionalDataHolder, Parsable {
    /**
     * The date and time when the outgoing payment was created.
     */
    createdAt?: Date | null;
    /**
     * The total amount that should be deducted from the sender's account when this outgoing payment has been paid.
     */
    debitAmount?: Amount | null;
    /**
     * Describes whether the payment failed to send its full amount.
     */
    failed?: boolean | null;
    /**
     * The total amount successfully deducted from the sender's account using the current outgoing payment grant.
     */
    grantSpentDebitAmount?: Amount | null;
    /**
     * The total amount successfully received (by all receivers) using the current outgoing payment grant.
     */
    grantSpentReceiveAmount?: Amount | null;
    /**
     * The URL identifying the outgoing payment.
     */
    id?: string | null;
    /**
     * Additional metadata associated with the outgoing payment. (Optional)
     */
    metadata?: OutgoingPaymentWithSpentAmounts_metadata | null;
    /**
     * The URL of the quote defining this payment's amounts.
     */
    quoteId?: string | null;
    /**
     * The total amount that should be received by the receiver when this outgoing payment has been paid.
     */
    receiveAmount?: Amount | null;
    /**
     * The URL of the incoming payment that is being paid.
     */
    receiver?: string | null;
    /**
     * The total amount that has been sent under this outgoing payment.
     */
    sentAmount?: Amount | null;
    /**
     * The URL of the wallet address from which this payment is sent.
     */
    walletAddress?: string | null;
}
/**
 * Additional metadata associated with the outgoing payment. (Optional)
 */
export interface OutgoingPaymentWithSpentAmounts_metadata extends AdditionalDataHolder, Parsable {
}
export interface PageInfo extends Parsable {
    /**
     * Cursor corresponding to the last element in the result array.
     */
    endCursor?: string | null;
    /**
     * Describes whether the data set has further entries.
     */
    hasNextPage?: boolean | null;
    /**
     * Describes whether the data set has previous entries.
     */
    hasPreviousPage?: boolean | null;
    /**
     * Cursor corresponding to the first element in the result array.
     */
    startCursor?: string | null;
}
export type PaymentMethod = (typeof PaymentMethodObject)[keyof typeof PaymentMethodObject];
/**
 * An **incoming payment** resource with public details.
 */
export interface PublicIncomingPayment extends AdditionalDataHolder, Parsable {
    /**
     * The URL of the authorization server endpoint for getting grants and access tokens for this wallet address.
     */
    authServer?: string | null;
    /**
     * The receivedAmount property
     */
    receivedAmount?: Amount | null;
}
/**
 * A **quote** resource represents the quoted amount details with which an Outgoing Payment may be created.
 */
export interface Quote extends Parsable {
    /**
     * The date and time when the quote was created.
     */
    createdAt?: Date | null;
    /**
     * The total amount that should be deducted from the sender's account when the corresponding outgoing payment has been paid. 
     */
    debitAmount?: Amount | null;
    /**
     * The date and time when the calculated `debitAmount` is no longer valid.
     */
    expiresAt?: string | null;
    /**
     * The URL identifying the quote.
     */
    id?: string | null;
    /**
     * The method property
     */
    method?: PaymentMethod | null;
    /**
     * The total amount that should be received by the receiver when the corresponding outgoing payment has been paid.
     */
    receiveAmount?: Amount | null;
    /**
     * The URL of the incoming payment that the quote is created for.
     */
    receiver?: string | null;
    /**
     * The URL of the wallet address from which this quote's payment would be sent.
     */
    walletAddress?: string | null;
}
/**
 * Serializes information the current object
 * @param Amount The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeAmount(writer: SerializationWriter, amount: Partial<Amount> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!amount || isSerializingDerivedType) { return; }
    writer.writeStringValue("assetCode", amount.assetCode);
    writer.writeNumberValue("assetScale", amount.assetScale);
    writer.writeStringValue("value", amount.value);
    writer.writeAdditionalData(amount.additionalData);
}
/**
 * Serializes information the current object
 * @param ErrorResponse The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeErrorResponse(writer: SerializationWriter, errorResponse: Partial<ErrorResponse> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!errorResponse || isSerializingDerivedType) { return; }
    writer.writeObjectValue<ErrorResponse_error>("error", errorResponse.errorEscaped, serializeErrorResponse_error);
    writer.writeAdditionalData(errorResponse.additionalData);
}
/**
 * Serializes information the current object
 * @param ErrorResponse_error The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeErrorResponse_error(writer: SerializationWriter, errorResponse_error: Partial<ErrorResponse_error> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!errorResponse_error || isSerializingDerivedType) { return; }
    writer.writeStringValue("code", errorResponse_error.code);
    writer.writeStringValue("description", errorResponse_error.description);
    writer.writeObjectValue<ErrorResponse_error_details>("details", errorResponse_error.details, serializeErrorResponse_error_details);
    writer.writeAdditionalData(errorResponse_error.additionalData);
}
/**
 * Serializes information the current object
 * @param ErrorResponse_error_details The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeErrorResponse_error_details(writer: SerializationWriter, errorResponse_error_details: Partial<ErrorResponse_error_details> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!errorResponse_error_details || isSerializingDerivedType) { return; }
    writer.writeAdditionalData(errorResponse_error_details.additionalData);
}
/**
 * Serializes information the current object
 * @param IlpPaymentMethod The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeIlpPaymentMethod(writer: SerializationWriter, ilpPaymentMethod: Partial<IlpPaymentMethod> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!ilpPaymentMethod || isSerializingDerivedType) { return; }
    writer.writeStringValue("ilpAddress", ilpPaymentMethod.ilpAddress);
    writer.writeStringValue("sharedSecret", ilpPaymentMethod.sharedSecret);
    writer.writeEnumValue<IlpPaymentMethod_type>("type", ilpPaymentMethod.type);
}
/**
 * Serializes information the current object
 * @param IncomingPayment The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeIncomingPayment(writer: SerializationWriter, incomingPayment: Partial<IncomingPayment> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!incomingPayment || isSerializingDerivedType) { return; }
    writer.writeBooleanValue("completed", incomingPayment.completed);
    writer.writeDateValue("createdAt", incomingPayment.createdAt);
    writer.writeDateValue("expiresAt", incomingPayment.expiresAt);
    writer.writeObjectValue<Amount>("incomingAmount", incomingPayment.incomingAmount, serializeAmount);
    writer.writeObjectValue<IncomingPayment_metadata>("metadata", incomingPayment.metadata, serializeIncomingPayment_metadata);
    writer.writeObjectValue<Amount>("receivedAmount", incomingPayment.receivedAmount, serializeAmount);
    writer.writeAdditionalData(incomingPayment.additionalData);
}
/**
 * Serializes information the current object
 * @param IncomingPayment_metadata The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeIncomingPayment_metadata(writer: SerializationWriter, incomingPayment_metadata: Partial<IncomingPayment_metadata> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!incomingPayment_metadata || isSerializingDerivedType) { return; }
    writer.writeAdditionalData(incomingPayment_metadata.additionalData);
}
/**
 * Serializes information the current object
 * @param IncomingPaymentWithMethods The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeIncomingPaymentWithMethods(writer: SerializationWriter, incomingPaymentWithMethods: Partial<IncomingPaymentWithMethods> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!incomingPaymentWithMethods || isSerializingDerivedType) { return; }
    serializeIncomingPayment(writer, incomingPaymentWithMethods, isSerializingDerivedType)
    writer.writeCollectionOfObjectValues<IlpPaymentMethod>("methods", incomingPaymentWithMethods.methods, serializeIlpPaymentMethod);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param OutgoingPayment The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeOutgoingPayment(writer: SerializationWriter, outgoingPayment: Partial<OutgoingPayment> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!outgoingPayment || isSerializingDerivedType) { return; }
    writer.writeDateValue("createdAt", outgoingPayment.createdAt);
    writer.writeObjectValue<Amount>("debitAmount", outgoingPayment.debitAmount, serializeAmount);
    writer.writeBooleanValue("failed", outgoingPayment.failed);
    writer.writeObjectValue<OutgoingPayment_metadata>("metadata", outgoingPayment.metadata, serializeOutgoingPayment_metadata);
    writer.writeObjectValue<Amount>("receiveAmount", outgoingPayment.receiveAmount, serializeAmount);
    writer.writeStringValue("receiver", outgoingPayment.receiver);
    writer.writeObjectValue<Amount>("sentAmount", outgoingPayment.sentAmount, serializeAmount);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param OutgoingPayment_metadata The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeOutgoingPayment_metadata(writer: SerializationWriter, outgoingPayment_metadata: Partial<OutgoingPayment_metadata> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!outgoingPayment_metadata || isSerializingDerivedType) { return; }
    writer.writeAdditionalData(outgoingPayment_metadata.additionalData);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param OutgoingPaymentWithSpentAmounts The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeOutgoingPaymentWithSpentAmounts(writer: SerializationWriter, outgoingPaymentWithSpentAmounts: Partial<OutgoingPaymentWithSpentAmounts> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!outgoingPaymentWithSpentAmounts || isSerializingDerivedType) { return; }
    writer.writeDateValue("createdAt", outgoingPaymentWithSpentAmounts.createdAt);
    writer.writeObjectValue<Amount>("debitAmount", outgoingPaymentWithSpentAmounts.debitAmount, serializeAmount);
    writer.writeBooleanValue("failed", outgoingPaymentWithSpentAmounts.failed);
    writer.writeObjectValue<Amount>("grantSpentDebitAmount", outgoingPaymentWithSpentAmounts.grantSpentDebitAmount, serializeAmount);
    writer.writeObjectValue<Amount>("grantSpentReceiveAmount", outgoingPaymentWithSpentAmounts.grantSpentReceiveAmount, serializeAmount);
    writer.writeObjectValue<OutgoingPaymentWithSpentAmounts_metadata>("metadata", outgoingPaymentWithSpentAmounts.metadata, serializeOutgoingPaymentWithSpentAmounts_metadata);
    writer.writeObjectValue<Amount>("receiveAmount", outgoingPaymentWithSpentAmounts.receiveAmount, serializeAmount);
    writer.writeStringValue("receiver", outgoingPaymentWithSpentAmounts.receiver);
    writer.writeObjectValue<Amount>("sentAmount", outgoingPaymentWithSpentAmounts.sentAmount, serializeAmount);
    writer.writeAdditionalData(outgoingPaymentWithSpentAmounts.additionalData);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param OutgoingPaymentWithSpentAmounts_metadata The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeOutgoingPaymentWithSpentAmounts_metadata(writer: SerializationWriter, outgoingPaymentWithSpentAmounts_metadata: Partial<OutgoingPaymentWithSpentAmounts_metadata> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!outgoingPaymentWithSpentAmounts_metadata || isSerializingDerivedType) { return; }
    writer.writeAdditionalData(outgoingPaymentWithSpentAmounts_metadata.additionalData);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param PageInfo The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializePageInfo(writer: SerializationWriter, pageInfo: Partial<PageInfo> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!pageInfo || isSerializingDerivedType) { return; }
    writer.writeStringValue("endCursor", pageInfo.endCursor);
    writer.writeBooleanValue("hasNextPage", pageInfo.hasNextPage);
    writer.writeBooleanValue("hasPreviousPage", pageInfo.hasPreviousPage);
    writer.writeStringValue("startCursor", pageInfo.startCursor);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param PublicIncomingPayment The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializePublicIncomingPayment(writer: SerializationWriter, publicIncomingPayment: Partial<PublicIncomingPayment> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!publicIncomingPayment || isSerializingDerivedType) { return; }
    writer.writeStringValue("authServer", publicIncomingPayment.authServer);
    writer.writeObjectValue<Amount>("receivedAmount", publicIncomingPayment.receivedAmount, serializeAmount);
    writer.writeAdditionalData(publicIncomingPayment.additionalData);
}
/**
 * Serializes information the current object
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param Quote The instance to serialize from.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeQuote(writer: SerializationWriter, quote: Partial<Quote> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!quote || isSerializingDerivedType) { return; }
    writer.writeDateValue("createdAt", quote.createdAt);
    writer.writeObjectValue<Amount>("debitAmount", quote.debitAmount, serializeAmount);
    writer.writeEnumValue<PaymentMethod>("method", quote.method);
    writer.writeObjectValue<Amount>("receiveAmount", quote.receiveAmount, serializeAmount);
    writer.writeStringValue("receiver", quote.receiver);
}
export const IlpPaymentMethod_typeObject = {
    Ilp: "ilp",
} as const;
export const PaymentMethodObject = {
    Ilp: "ilp",
} as const;
/* tslint:enable */
/* eslint-enable */
