/* tslint:disable */
/* eslint-disable */
// Generated by Microsoft Kiota
// @ts-ignore
import { createAmountFromDiscriminatorValue, createErrorResponseFromDiscriminatorValue, createIncomingPaymentFromDiscriminatorValue, createIncomingPaymentWithMethodsFromDiscriminatorValue, createPageInfoFromDiscriminatorValue, serializeAmount, serializeIncomingPayment, serializeIncomingPaymentWithMethods, serializePageInfo, type Amount, type ErrorResponse, type IncomingPayment, type IncomingPaymentWithMethods, type PageInfo } from '../models/index.js';
// @ts-ignore
import { IncomingPaymentsItemRequestBuilderNavigationMetadata, IncomingPaymentsItemRequestBuilderRequestsMetadata, type IncomingPaymentsItemRequestBuilder } from './item/index.js';
// @ts-ignore
import { type AdditionalDataHolder, type BaseRequestBuilder, type KeysToExcludeForNavigationMetadata, type NavigationMetadata, type Parsable, type ParsableFactory, type ParseNode, type RequestConfiguration, type RequestInformation, type RequestsMetadata, type SerializationWriter } from '@microsoft/kiota-abstractions';

/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {IncomingPaymentsGetResponse}
 */
// @ts-ignore
export function createIncomingPaymentsGetResponseFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoIncomingPaymentsGetResponse;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {IncomingPaymentsPostRequestBody_metadata}
 */
// @ts-ignore
export function createIncomingPaymentsPostRequestBody_metadataFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoIncomingPaymentsPostRequestBody_metadata;
}
/**
 * Creates a new instance of the appropriate class based on discriminator value
 * @param parseNode The parse node to use to read the discriminator value and create the object
 * @returns {IncomingPaymentsPostRequestBody}
 */
// @ts-ignore
export function createIncomingPaymentsPostRequestBodyFromDiscriminatorValue(parseNode: ParseNode | undefined) : ((instance?: Parsable) => Record<string, (node: ParseNode) => void>) {
    return deserializeIntoIncomingPaymentsPostRequestBody;
}
/**
 * The deserialization information for the current model
 * @param IncomingPaymentsGetResponse The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoIncomingPaymentsGetResponse(incomingPaymentsGetResponse: Partial<IncomingPaymentsGetResponse> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "pagination": n => { incomingPaymentsGetResponse.pagination = n.getObjectValue<PageInfo>(createPageInfoFromDiscriminatorValue); },
        "result": n => { incomingPaymentsGetResponse.result = n.getCollectionOfObjectValues<IncomingPayment>(createIncomingPaymentFromDiscriminatorValue); },
    }
}
/**
 * The deserialization information for the current model
 * @param IncomingPaymentsPostRequestBody The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoIncomingPaymentsPostRequestBody(incomingPaymentsPostRequestBody: Partial<IncomingPaymentsPostRequestBody> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
        "expiresAt": n => { incomingPaymentsPostRequestBody.expiresAt = n.getDateValue(); },
        "incomingAmount": n => { incomingPaymentsPostRequestBody.incomingAmount = n.getObjectValue<Amount>(createAmountFromDiscriminatorValue); },
        "metadata": n => { incomingPaymentsPostRequestBody.metadata = n.getObjectValue<IncomingPaymentsPostRequestBody_metadata>(createIncomingPaymentsPostRequestBody_metadataFromDiscriminatorValue); },
        "walletAddress": n => { incomingPaymentsPostRequestBody.walletAddress = n.getStringValue(); },
    }
}
/**
 * The deserialization information for the current model
 * @param IncomingPaymentsPostRequestBody_metadata The instance to deserialize into.
 * @returns {Record<string, (node: ParseNode) => void>}
 */
// @ts-ignore
export function deserializeIntoIncomingPaymentsPostRequestBody_metadata(incomingPaymentsPostRequestBody_metadata: Partial<IncomingPaymentsPostRequestBody_metadata> | undefined = {}) : Record<string, (node: ParseNode) => void> {
    return {
    }
}
export interface IncomingPaymentsGetResponse extends AdditionalDataHolder, Parsable {
    /**
     * The pagination property
     */
    pagination?: PageInfo | null;
    /**
     * The result property
     */
    result?: IncomingPayment[] | null;
}
export interface IncomingPaymentsPostRequestBody extends Parsable {
    /**
     * The date and time when payments into the incoming payment must no longer be accepted.
     */
    expiresAt?: Date | null;
    /**
     * The maximum amount that should be paid into the wallet address under this incoming payment.
     */
    incomingAmount?: Amount | null;
    /**
     * Additional metadata associated with the incoming payment. (Optional)
     */
    metadata?: IncomingPaymentsPostRequestBody_metadata | null;
    /**
     * The URL of an Open Payments wallet address
     */
    walletAddress?: string | null;
}
/**
 * Additional metadata associated with the incoming payment. (Optional)
 */
export interface IncomingPaymentsPostRequestBody_metadata extends AdditionalDataHolder, Parsable {
}
/**
 * Builds and executes requests for operations under /incoming-payments
 */
export interface IncomingPaymentsRequestBuilder extends BaseRequestBuilder<IncomingPaymentsRequestBuilder> {
    /**
     * Gets an item from the ApiSdk.incomingPayments.item collection
     * @param id Sub-resource identifier
     * @returns {IncomingPaymentsItemRequestBuilder}
     */
     byId(id: string) : IncomingPaymentsItemRequestBuilder;
    /**
     * List all incoming payments on the wallet address
     * @param requestConfiguration Configuration for the request such as headers, query parameters, and middleware options.
     * @returns {Promise<IncomingPaymentsGetResponse>}
     * @throws {ErrorResponse} error when the service returns a 401 status code
     * @throws {ErrorResponse} error when the service returns a 403 status code
     */
     get(requestConfiguration?: RequestConfiguration<IncomingPaymentsRequestBuilderGetQueryParameters> | undefined) : Promise<IncomingPaymentsGetResponse | undefined>;
    /**
     * A client MUST create an **incoming payment** resource before it is possible to send any payments to the wallet address.When a client creates an **incoming payment** the receiving Account Servicing Entity generates unique payment details that can be used to address payments to the account and returns these details to the client as properties of the new **incoming payment**. Any payments received using those details are then associated with the **incoming payment**.All of the input parameters are _optional_.For example, the client could use the `metadata` property to store an external reference on the **incoming payment** and this can be shared with the account holder to assist with reconciliation.If `incomingAmount` is specified and the total received using the payment details equals or exceeds the specified `incomingAmount`, then the receiving Account Servicing Entity MUST reject any further payments and set `completed` to `true`.If an `expiresAt` value is defined, and the current date and time on the receiving Account Servicing Entity's systems exceeds that value, the receiving Account Servicing Entity MUST reject any further payments.
     * @param body The request body
     * @param requestConfiguration Configuration for the request such as headers, query parameters, and middleware options.
     * @returns {Promise<IncomingPaymentWithMethods>}
     * @throws {ErrorResponse} error when the service returns a 401 status code
     * @throws {ErrorResponse} error when the service returns a 403 status code
     */
     post(body: IncomingPaymentsPostRequestBody, requestConfiguration?: RequestConfiguration<object> | undefined) : Promise<IncomingPaymentWithMethods | undefined>;
    /**
     * List all incoming payments on the wallet address
     * @param requestConfiguration Configuration for the request such as headers, query parameters, and middleware options.
     * @returns {RequestInformation}
     */
     toGetRequestInformation(requestConfiguration?: RequestConfiguration<IncomingPaymentsRequestBuilderGetQueryParameters> | undefined) : RequestInformation;
    /**
     * A client MUST create an **incoming payment** resource before it is possible to send any payments to the wallet address.When a client creates an **incoming payment** the receiving Account Servicing Entity generates unique payment details that can be used to address payments to the account and returns these details to the client as properties of the new **incoming payment**. Any payments received using those details are then associated with the **incoming payment**.All of the input parameters are _optional_.For example, the client could use the `metadata` property to store an external reference on the **incoming payment** and this can be shared with the account holder to assist with reconciliation.If `incomingAmount` is specified and the total received using the payment details equals or exceeds the specified `incomingAmount`, then the receiving Account Servicing Entity MUST reject any further payments and set `completed` to `true`.If an `expiresAt` value is defined, and the current date and time on the receiving Account Servicing Entity's systems exceeds that value, the receiving Account Servicing Entity MUST reject any further payments.
     * @param body The request body
     * @param requestConfiguration Configuration for the request such as headers, query parameters, and middleware options.
     * @returns {RequestInformation}
     */
     toPostRequestInformation(body: IncomingPaymentsPostRequestBody, requestConfiguration?: RequestConfiguration<object> | undefined) : RequestInformation;
}
/**
 * List all incoming payments on the wallet address
 */
export interface IncomingPaymentsRequestBuilderGetQueryParameters {
    /**
     * The cursor key to list from.
     */
    cursor?: string;
    /**
     * The number of items to return after the cursor.
     */
    first?: number;
    /**
     * The number of items to return before the cursor.
     */
    last?: number;
    /**
     * URL of a wallet address hosted by a Rafiki instance.
     */
    walletAddress?: string;
}
/**
 * Serializes information the current object
 * @param IncomingPaymentsGetResponse The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeIncomingPaymentsGetResponse(writer: SerializationWriter, incomingPaymentsGetResponse: Partial<IncomingPaymentsGetResponse> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!incomingPaymentsGetResponse || isSerializingDerivedType) { return; }
    writer.writeObjectValue<PageInfo>("pagination", incomingPaymentsGetResponse.pagination, serializePageInfo);
    writer.writeCollectionOfObjectValues<IncomingPayment>("result", incomingPaymentsGetResponse.result, serializeIncomingPayment);
    writer.writeAdditionalData(incomingPaymentsGetResponse.additionalData);
}
/**
 * Serializes information the current object
 * @param IncomingPaymentsPostRequestBody The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeIncomingPaymentsPostRequestBody(writer: SerializationWriter, incomingPaymentsPostRequestBody: Partial<IncomingPaymentsPostRequestBody> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!incomingPaymentsPostRequestBody || isSerializingDerivedType) { return; }
    writer.writeDateValue("expiresAt", incomingPaymentsPostRequestBody.expiresAt);
    writer.writeObjectValue<Amount>("incomingAmount", incomingPaymentsPostRequestBody.incomingAmount, serializeAmount);
    writer.writeObjectValue<IncomingPaymentsPostRequestBody_metadata>("metadata", incomingPaymentsPostRequestBody.metadata, serializeIncomingPaymentsPostRequestBody_metadata);
    writer.writeStringValue("walletAddress", incomingPaymentsPostRequestBody.walletAddress);
}
/**
 * Serializes information the current object
 * @param IncomingPaymentsPostRequestBody_metadata The instance to serialize from.
 * @param isSerializingDerivedType A boolean indicating whether the serialization is for a derived type.
 * @param writer Serialization writer to use to serialize this model
 */
// @ts-ignore
export function serializeIncomingPaymentsPostRequestBody_metadata(writer: SerializationWriter, incomingPaymentsPostRequestBody_metadata: Partial<IncomingPaymentsPostRequestBody_metadata> | undefined | null = {}, isSerializingDerivedType: boolean = false) : void {
    if (!incomingPaymentsPostRequestBody_metadata || isSerializingDerivedType) { return; }
    writer.writeAdditionalData(incomingPaymentsPostRequestBody_metadata.additionalData);
}
/**
 * Uri template for the request builder.
 */
export const IncomingPaymentsRequestBuilderUriTemplate = "{+baseurl}/incoming-payments?wallet-address={wallet%2Daddress}{&cursor*,first*,last*}";
/**
 * Mapper for query parameters from symbol name to serialization name represented as a constant.
 */
const IncomingPaymentsRequestBuilderGetQueryParametersMapper: Record<string, string> = {
    "walletAddress": "wallet%2Daddress",
};
/**
 * Metadata for all the navigation properties in the request builder.
 */
export const IncomingPaymentsRequestBuilderNavigationMetadata: Record<Exclude<keyof IncomingPaymentsRequestBuilder, KeysToExcludeForNavigationMetadata>, NavigationMetadata> = {
    byId: {
        requestsMetadata: IncomingPaymentsItemRequestBuilderRequestsMetadata,
        navigationMetadata: IncomingPaymentsItemRequestBuilderNavigationMetadata,
        pathParametersMappings: ["id"],
    },
};
/**
 * Metadata for all the requests in the request builder.
 */
export const IncomingPaymentsRequestBuilderRequestsMetadata: RequestsMetadata = {
    get: {
        uriTemplate: IncomingPaymentsRequestBuilderUriTemplate,
        responseBodyContentType: "application/json",
        errorMappings: {
            401: createErrorResponseFromDiscriminatorValue as ParsableFactory<Parsable>,
            403: createErrorResponseFromDiscriminatorValue as ParsableFactory<Parsable>,
        },
        adapterMethodName: "send",
        responseBodyFactory:  createIncomingPaymentsGetResponseFromDiscriminatorValue,
        queryParametersMapper: IncomingPaymentsRequestBuilderGetQueryParametersMapper,
    },
    post: {
        uriTemplate: IncomingPaymentsRequestBuilderUriTemplate,
        responseBodyContentType: "application/json",
        errorMappings: {
            401: createErrorResponseFromDiscriminatorValue as ParsableFactory<Parsable>,
            403: createErrorResponseFromDiscriminatorValue as ParsableFactory<Parsable>,
        },
        adapterMethodName: "send",
        responseBodyFactory:  createIncomingPaymentWithMethodsFromDiscriminatorValue,
        requestBodyContentType: "application/json",
        requestBodySerializer: serializeIncomingPaymentsPostRequestBody,
        requestInformationContentSetMethod: "setContentFromParsable",
    },
};
/* tslint:enable */
/* eslint-enable */
